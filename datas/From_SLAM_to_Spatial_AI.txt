FutureMapping: The Computational Structure of Spatial AI Systems
Andrew J. Davison
a.davison@imperial.ac.uk
Department of Computing, Imperial College London, UK
Abstract
We discuss and predict the evolution of Simultaneous Lo-
calisation and Mapping (SLAM) into a general geometric
and semantic ‘Spatial AI’ perception capability for intel-
ligent embodied devices. A big gap remains between the
visual perception performance that devices such as aug-
mented reality eyewear or comsumer robots will require
and what is possible within the constraints imposed by real
products. Co-design of algorithms, processors and sensors
will be needed. We explore the computational structure of
current and future Spatial AI algorithms and consider this
within the landscape of ongoing hardware developments.
1. Introduction
While the usually stated goal of computer vision is to re-
port ‘what’ is ‘where’ in an image in a general way, Spatial
AI is the online problem where vision is to be used, usually
alongside other sensors, as part of the Artiﬁcial Intelligence
(AI) which permits an embodied device to interact usefully
with its environment. This device must operate in real-time,
in a context, and with goals. It may be what we would
clasically think of as a robot, a fully autonomous artiﬁcial
agent; or it could be a device like an AR headset designed
to be used by a human to augment their capabilities. As re-
cently clariﬁed by Markoff [31], either autonomous AI as in
a robot or an ‘Intelligence Augmentation’ (IA) system such
as AR have very similar requirements in terms of Spatial
AI.
So the goal of a Spatial AI system is not abstract scene
understanding, but continuously to capture the right infor-
mation, and to build the right representations, to enable real-
time interpretation and action. The design of such a system
will be framed at one end by task requirements on its per-
formance, and at the other end by constraints imposed by
the setting of the device in which it is to be used.
Let us consider the example of a mass market house-
hold robot product of the future, which is set the tasks of
monitoring, cleaning and tidying a set of rooms. Its task
requirements will include the ability to check whether fur-
niture and objects have moved or changed; to clean surfaces
and know when they are clean; to recognise, move and ma-
nipulate objects; and to deal promptly and respectfully with
humans by moving out of the way or assisting them. Mean-
while, its Spatial AI system, comprising one or more cam-
eras, supporting sensors, processors and algorithms, will be
constrained by factors including the price, aesthetics, size,
safety, and power usage, which must ﬁt within the range of
a consumer product.
As a second example, this time from the IA domain, we
imagine a future augmented reality system which should
provide its wearer with a robust spatial memory of all of
the places, objects and people they have encountered, en-
abling things such as easily ﬁnding lost objects, and the
placing of virtual notes or other annotations on any world
entity. To achieve wide adoption, the device should have
the size, weight and form factor of a standard pair of spec-
tacles (65g), and operate all day without needing a battery
charge (<1W power usage).
There is currently a big gap between what such powerful
Spatial AI systems need to do in useful applications, and
what can be achieved with current technology under real
world constraints. There is much promising research on the
algorithms and technology needed, but robust performance
is still difﬁcult even when expensive, bulky sensors and un-
limited computing resources are available. The gap between
reality and desired performance becomes much more sig-
niﬁcant still when the constraints on real products are taken
into account. In particular, the size, cost and power require-
ments of the computer processors currently enabling ad-
vanced robot vision are very far from ﬁtting the constraints
imposed by these applications we envisage.
The PAMELA project from the Universities of Manch-
ester, Edinburgh and Imperial College has opened up re-
search in this area by taking a broad look at the interaction
of Spatial AI algorithms and the increasingly heterogeneous
processors they must run on, producing pioneering work
such as the SLAMBench framework [38, 4]. As the project
nears its end, in this paper we take a long view of Spatial
AI research, make some analysis of the key computational
structure of these problems, and taking account of ongoing
arXiv:1803.11288v1  [cs.AI]  29 Mar 2018
trends in processor technology make some predictions for
the future of this ﬁeld.
2. SLAM, Spatial AI and Machine Learning
The research area of visual SLAM (Simultaneous Local-
isation and Mapping) in robotics and computer vision has
long been concerned with real-time, incremental estimation
of the shape and structure of the scene around a robot, and
the robot’s position within it. The level of scene representa-
tion that has been possible in real-time SLAM has gradually
improved, from sparse features (e.g. [8]) to dense (e.g. [42])
maps and now increasingly semantic labels [33, 54].
Commercial SLAM provider SLAMcore Ltd. [1] refers
to sparse localisation, dense mapping and semantic la-
belling as Levels 1, 2 and 3 capabilities respectively. These
are ongoing steps along SLAM’s evolution towards spatial
perception. Observing the steady and consistent progress of
SLAM over more than 20 years, we have become conﬁdent
that the operation of current and forseeable SLAM systems
is the best guide we have for the algorithmic structure of
future Spatial AI.
Spatial AI will be fundamental enabling technology for
a the next generation of smart robots, mobile devices and
other products that we can’t yet imagine; a new layer of
technology that could eventually be pervasive. In the re-
cent technical report from leading UC Berkeley researchers
on systems challenges for AI [51], it is argued that devices
which can act intelligently in their environments via con-
tinual learning must be capable of Simulated Reality (SR)
which can “faithfully simulate the real-world environment,
as the environment changes continually and unexpectedly,
and run faster than real time”. Judea Pearl, recently dis-
cussing efﬁcient situated learning and the need to reason
about causation [43], argues that “what humans possessed
that other species lacked was a mental representation, a
blue-print of their environment which they could manipu-
late at will to imagine alternative hypothetical environments
for planning and learning”. Both of these describe exactly
what we envision as the end-goal of SLAM’s ongoing evo-
lution into Spatial AI.
Most Spatial AI systems will have multiple applications,
not all predictable at the time of design. We therefore make
the following hypothesis: When a device must operate for
an extended period of time, carry out a wide variety of tasks
(not all of which are necessarily known at design time), and
communicate with other entities including humans, its Spa-
tial AI system should build a general and persistent scene
representation which is close to metric 3D geometry, at least
locally, and is human understandable. To be clear, this def-
inition leaves a lot of space for many choices about scene
representation, with both learned and designed elements,
but rules out algorithms which make use of very speciﬁc
task-focused representations.
Our second hypothesis is that: The usefulness of a Spa-
tial AI system for a wide range of tasks is well represented
by a relatively small number of performance measures.
That is to say that whether the system is to be used to guide
the autonomous ﬂight of a delivery drone in a tight space,
or a household robot to tidy a room, or to enable an aug-
mented reality display to add synthetic objects to a scene,
then even though these applications certainly have differ-
ent requirements and constraints, the suitability of a Spatial
AI system for each can be speciﬁed by a the speciﬁcation
of a small number of performance parameters. The obvi-
ous parameters describe aspects like global device localisa-
tion accuracy and update latency, but we believe that there
other metrics which will be more meaningful for applica-
tions, like distance to surface contact prediction accuracy,
object identiﬁcation accuracy or tracking robustness. We
will discuss performance metrics further in Section 9.
For the purposes of the rest of this paper, we will there-
fore call such a module which incrementally builds and
maintains a generally useful, close to metric scene repre-
sentation, in real-time and from primarily visual input, and
with quantiﬁable performance metrics, a Spatial AI system.
2.1. Machine Learning
In recent years, Machine Learning (ML) has increasingly
come to the fore in AI, and overcome human-designed ap-
proaches in many problems. In machine learning, the pa-
rameters of a black box computational unit which trans-
forms inputs to outputs are learned by adjusting them on the
basis of training data, with the aim of optimising its perfor-
mance either when compared to explicit labels provided by
an external source (supervised learning), or more indirectly
by judging performance against high level task goals over a
period of time (reinforcement learning). Machine Learning
contrasts with estimation methods where the computational
unit to achieve an AI task is explicitly hand-designed with
nameable variables, modules, algorithms and other struc-
tures.
Computer vision has proved to be a very successful do-
main for the application of ML. As is well known, Deep
Learning approaches mainly based on Convolutional Neu-
ral Networks (CNNs) have become the dominant approach
to achieving state of the art results in many vision problems,
such as image classiﬁcation or segmentation.
More recently, deep learning has started to show promis-
ing results on problems in vision-guided robotics (e.g.
[13]). In these approaches, a deep network which processes
the raw pixels of incoming images is trained ‘end to end’ by
supervision from a non-learned system (e.g. [21]), or via re-
inforcement based on the the achievement of discrete tasks
such as object placement or local navigation. These net-
works learn directly to output motor control signals based
on visual input, and therefore any internal representation
they need (such as the shape of the environment, and the
robot’s position within it) are represented within the net-
work itself as required to achieve the task, in an implicit
form which is not accessible beyond the task at hand.
In general Spatial AI problems, there has so far been
less success in machine learning methods which incremen-
tally improve a world representation over time from multi-
ple measurements. Such learning requires a computational
unit which has memory and captures its own internal repre-
sentaion over time. A Recurrent Neural Network (RNN) is
the fundamental concept of a network whose activations and
outputs depend not just ‘single shot’ on the current input
data but also on internal states which are the outcome of pre-
vious inputs. There are many related ideas and also efforts
to interface deep networks with explicit memory blocks.
In Spatial AI, training an RNN or similar to produce use-
ful output sequentially from a real-time stream of input data
requires it to capture within its internal state a persistent set
of concepts which must closely relate to the shape and qual-
ities of the environment around the device. We have cer-
tainly seen some success with methods aiming to do this,
such as the work of Wen et al. [55] on estimating incre-
mental visual odometry from video using an RNN whose
training was via a supervised known pose signal.
However, a group of methods which seems very promis-
ing aims to impose structure on what is learned by a net-
work. Gupta et al. [16] presented a method for local naviga-
tion which forces a deep network to learn about a robot’s en-
vironment in a manner which tends towards a metric grid by
presenting it with metric spatial transformations based on
the robot’s known motion in 2D. Zhou et al. [59] have excit-
ingly shown how networks to estimate incremental camera
motion and scene depth can be trained in a coupled manner
from unlabelled video data, using photoconsistency via the
geometric warping between textured depth frames as self-
supervision.
These are learning architectures which use the designer’s
knowledge of the structure of the underlying estimation
problem to increase what can be gained from training data,
and can be seen as hybrids between pure black box learning
and hand-built estimation. Another key paper in this area
introduced the idea of Spatial Transformer Networks [20],
as generalised in Handa et al.’s gvnn [17]. Why should a
neural network have to use some of its capacity to learn a
well understood and modelled concept like 3D geometry?
Instead it can focus its learning on the harder to capture
factors such as correspondence of surfaces under varying
lighting.
These insights support our ﬁrst hypothesis that future
Spatial AI systems will have recognisable and general map-
ping capability which builds a close to metric 3D model.
This ‘SLAM’ element may either be embedded within a
specially architected neural network, or be more explicitly
separated from machine learning in another module which
stores and updates map properties using standard estima-
tion methods (as in SemanticFusion [33] for instance). In
both cases, there should be an identiﬁable region of memory
which contains a representation of space with some recog-
nisable geometric structure.
Besides utility, such AI systems will have the additional
advantage of using representations that can be communi-
cated to and understood by humans, and therefore in princi-
ple controlled.
2.2. Closed Loop SLAM
As a sensor platform carrying at least one camera and
other sensors moves through the world, its motion either un-
der active control or provided by another agent, the essen-
tial algorithmic ways that a Spatial AI system of any variety
works can be summarised as follows:
1. Starting from and continuing to make use of prior
knowledge of the type of scene it is working in, the sys-
tem uses data from its sensors to incrementally build
and reﬁne a persistent world model which captures ab-
stracted geometric, appearance and semantic informa-
tion about its environment. It also models and incre-
mentally estimates the state of the moving camera plat-
form relative to the world. The amount of data stored
to represent a region of space of a certain size will have
a maximum bound so that if the sensor spends a long
time in one region the size of the representation does
not grow arbitrarily.
2. As new image data is captured from the moving cam-
era, it is compared with the current world model. With
low latency, the system must decide which new data
is not important and which can be used to update the
model’s persistent estimates. The task of matching up
sensor data to the relevant parts of the model is called
data association.
3. The model update is often considered as consisting of
tracking, which is getting new estimates of the sensor
platform’s position/state, and map update where the
scene model is improved and expanded. This division
is however somewhat arbitrary.
The key computational quality of this approach is its
closed loop nature, where the world model is persistent and
incrementally updated, representing in an abstracted form
all of the useful data which has been acquired to date, and is
used in the real-time loop for data association and tracking.
This is in contrast with vision systems which perform in-
cremental estimation (such as visual odometry, where cam-
era motion is estimated from frame to frame but long term
data structures are not retained), or which can only achieve
global consistency with off-line, after the event batch com-
putation. That is not to say that in a closed loop Spatial AI
system every computation should happen at a ﬁxed rate, but
more importantly that it should be available when needed to
allow real-time operation of the whole system to continue
without pauses.
Closed loop SLAM has generally been enabled by prob-
abilistic estimation, the fundamental approach building
models which summarise past data in a form which ac-
knowledges uncertainty and allows new data to be correctly
weighted and fused. In sparse feature-based SLAM, proba-
bilistic fusion is implemented via tools such as the Extended
Kalman Filter (as in [8]) or incremental non-linear optimi-
sation (as in [28]).
Sparse feature maps are useful as landmark sets for posi-
tion estimation, but do not provide much information about
the scene around a camera, and progress has more recently
been towards systems aiming to do better, via dense map-
ping and now semantic mapping.
Ultimately, if a scene
model is fully generative then it can be used to make com-
plete predictions about sensor data. This is important be-
cause then in principle every piece of sensor data can be
compared with the model prediction to uncover what is pre-
viously unseen or changed in the scene. In simple terms,
for a system and to recognise something which is unusual,
it must keep up to date a full predictive model of what is
normal.
The latest real-time SLAM systems are hybrids, com-
bining estimation of tracking and dense surface shape with
learned components for labelling and recognition (e.g. Se-
manticFusion [33]).
As mentioned earlier, other learned
components are now looking promising for other elements
of a full system such as VO and depth estimation (e.g.
Zhou et al. [59]). We forsee these components coming to-
gether in an increasingly tight and interlinked fashion, help-
ing and feeding into each other. While SemanticFusion cur-
rently uses geometric SLAM and CNN-based labelling as
essentially separate modules which are fused into a ﬁnal la-
belled map output, systems coming in the near future will
be closely integrated in a tight loop which will surely give
much better performance. For instance, a CNN for labelling
which takes as input not just a new live image frame but also
the current set of label distributions reprojected from the 3D
map should be much better, and ideas like this are starting
to be proven [58].
One clear goal is to create a SLAM system which can as
far as possible understand a scene directly and efﬁciently at
the level of recognised objects and entities (as in the pro-
totype system SLAM++ [49]), reserving bottom-up recon-
struction and labelling for unfamiliar elements. Whether
the components making up such a system are designed or
learned may not have a big impact on the overall computa-
tional structure.
Our main aim in the rest of this paper is therefore to anal-
yse the computational structure of Spatial AI systems, while
avoiding pinning down speciﬁcs where this is difﬁcult, and
to make some predictions and tentative design choices about
their implementation going forward. A crucial element of
this is that Spatial AI is fundamentally an embodied, real-
time problem. We believe strongly that the design of the
algorithms and data structures required should take place in
a tightly integrated manner with that of the physical pro-
cessors and sensors which together form a whole system.
In the next section we will therefore consider the relevant
landscape in processor and sensor design.
3. The Future Landscape of Processor and
Sensor Hardware
SLAM research was for many years conducted in the era
when single core CPU processors could reliably be counted
on to double in clock speed, and therefore serial proces-
sor capability, every 1–2 years.
In recent years this has
stopped being true. The strict deﬁnition of Moore’s Law,
describing the rate of doubling of transistor density in inte-
grated circuits, has continued to hold well into the current
era. What has changed is that this can no longer be propor-
tionally translated into serial CPU performance, due to the
breakdown of another less well known rule of thumb called
Dennard Scaling, which states that as transistors get smaller
their power density stays constant. When transistors are re-
duced down to today’s nanometre sizes, not so far from the
size of the atoms they are made from, they leak current and
heat up. This ‘power wall’ limits the clock speed at which
they can reasonably be run without overheating uncontrol-
lably to something around 4GHz.
Processor designers must therefore increasingly look to-
wards alternative means than simply faster clocks to im-
prove computation performance. The processor landscape
is becoming much more complex, parallel and specialised,
as described well in Sutter’s online article ‘Welcome to
the Jungle’ [53]. Processor design is becoming more var-
ied and complex even in ‘cloud’ data centres. Pressure to
move away from CPUs is even stronger in embedded ap-
plications like Spatial AI, because here power usage is a
critical issue, and parallel, heteregeneous, specialised pro-
cessors seem to be the only route to achieving the compu-
tational performance Spatial AI needs within power restric-
tions which will ﬁt real products. So while current embed-
ded vision systems, e.g. for drones, often use CPU only
implementations of SLAM algorithms (rather than requir-
ing GPUs), we believe that this is not the right approach
for the longer term. While current desktop GPUs are cer-
tainly power-hungry, Spatial AI must eventually embrace
parallelism and heterogeneity in computation, and accept
that this will be the dominant paradigm going forward for
practical systems.
Mainstream geometrical computer vision started to take
advantage of parallel processing in the form of GPUs nearly
10 years ago (e.g. [45]), and in Spatial AI this led to break-
throughs in dense SLAM [42, 41]. The SIMT (Single In-
struction, Multiple Threads) parallelism that GPUs provide
is well suited to elements of real-time vision where the same
operation needs to be applied to every element of a regu-
lar array in image or map space. Concurrently, GPUs were
central to the emergence of deep learning in computer vi-
sion [27], by providing the computational resource to en-
able neural networks of sufﬁcient scale to be trained to ﬁ-
nally prove their worth in signiﬁcant tasks such as image
classiﬁcation.
The move from CPUs to GPUs as the main processing
workhorse for computer vision is only the beginning of how
processing technology is going to evolve. We forsee a fu-
ture where an embedded Spatial AI system will have a het-
erogeneous, multi-element, specialised architecture, where
low power operation must be achieved together with high
performance. A standard SoC (system-on-chip) for embed-
ded vision ten years from now, which might be used in a
personal mobile device, drone or AR headset, will be likely
to still have elements which are similar in design to to-
day’s CPUs and GPUs, due to their ﬂexibility and the huge
amount of useful software they can run. However, it is also
likely to have a number of specialised processors optimised
for low power real-time vision.
The key to efﬁcient processing which is both fast and
consumes little power is to divide computation between a
large number of relatively low clock-rate or otherwise sim-
ple cores, and to minimise the movement of data between
them. A CPU pulls and pushes small pieces of data one by
one from and to a separate main memory store as it performs
computation, with local caching of regularly used data the
only mechanism for reducing the ﬂow. Programming for
a single CPU is straightforward, because any type of algo-
rithm can be broken down into sequential steps with access
to a single central memory store, but the piece by piece ﬂow
of data to and from central memory has a huge power cost.
More efﬁcient processor designs aim to keep process-
ing and the data operated on close together, and to limit
the transmission of intermediate results. The ideal way to
achieve this is a close match between the design of a pro-
cessor/storage architecture and the algorithm it must run. A
GPU certainly has large advantages over a CPU for many
computer vision processing tasks, but in the end a GPU is a
processor designed originally for computer graphics rather
than vision and AI. Its SIMT architecture can efﬁciently run
algorithms where the same operation is carried out simulta-
neously on many different data elements. In a full Spatial
AI system, there are still many aspects which do not ﬁt well
with this, and a joint CPU/GPU architecture is currently
needed with substantial data transfer between the two.
While it is relatively accessible to design custom ‘accel-
erator’ processors which could implement certain speciﬁc
low-level algorithms with high efﬁciency (see for instance
the OpenVX project from the Khronos Group), there has
been relatively little work until recently on thinking about
the whole computational structure of whole close loop em-
bedded systems like Spatial AI. It is certainly true now that
low power vision is seen as an increasingly important aim
in industry, and custom processors to achieve this have been
developed such as Movidius’ Myriad series. These proces-
sors combine low power CPU-like, DSP-like and custom el-
ements in a complete package. The ‘HPU’ custom-designed
by Microsoft for their Hololens AR headset is rather similar
in design, and the recently announced second version will
include additional custom hardware support for neural net-
works.
If we try to look further ahead, we can conceive of pro-
cessor designs which offer the possibility of a much closer
match between architecture and algorithms. Highly rele-
vant to our aims are major efforts which are now taking
place on new ways of doing large-scale processing by being
made up from large numbers of independent and relatively
low-spec cores with the emphasis on communication. SpiN-
Naker [15] is a major research project from the University
of Manchester which aims to build machines to emulate bi-
ological brains. It has produced a prototype machine made
up from boards which each have hundreds of ARM cores,
and with up to a million cores in total. With the rather dif-
ferent commercial aim of providing an important new type
of processor for AI, Graphcore is a UK company develop-
ing ‘IPU’ processors which comprise thousands of highly
interconnected cores on a single chip.
Both of these projects are primarily being designed with
efﬁcient implementation of neural networks in mind, in
the case of both SpiNNaker and Graphcore with the belief
that the important matter is the overall topology of a large
number of cores, each performing different operations but
highly and efﬁciently inter-connected in a graph conﬁgura-
tion adapted to the use case. These designs have not taken
strong decisions about the type of processing carried out at
each core, or the type of messages they can exchange, with
the desire to leave these matters to the choice of future pro-
grammers. This is as opposed to more explicitly neuromor-
phic architectures aiming to implement particular models of
the operation of biological brains, such as IBM’s Truenorth
project.
Such architectures are not yet close to ready for embed-
ded vision, but seem to offer great long term potential for
the design of Spatial AI systems where the graph structure
of the algorithms and memory stores we use can be matched
to the implementation on the processor in a custom and po-
tentially highly efﬁcient way. We will consider this in more
detail later on.
But we also believe that we should go further than think-
ing of mapping Spatial AI to a single processor, even when
it has an internal graph architecture. A more general con-
cept of a graph applies to communication to cameras and
other sensors, actuators and other outputs, and potentially
entirely off-board computing resources in the cloud.
A particularly important consideration is the real-time
data ﬂow between the one or more camera sensors in a Spa-
tial AI system and the main processing resource where map
storage and processing occurs. Video data is huge and ex-
pensive to transmit. However, it is highly redundant, both
temporally and spatially: nearby pixels in both space and
time tend to have similar values.
The concept of a camera is today becoming increasingly
broad with ongoing innovation by sensor designers, and for
our purposes we consider any device which essentially cap-
tures an array of light measurements to be a visual sensor.
Most are passive in that they record and measure the ambi-
ent light which reaches them from their surroundings, while
another large class of cameras emit their own light in a more
or less controlled fashion. In Spatial AI, many types of
camera have been used, with the most common being pas-
sive monocular and stereo camera rigs, and depth cameras
based on structured light or time of ﬂight concepts. Every
camera design represents a choice in terms of the quality of
information it provides (measured in such ways as spatial
and temporal resolution and dynamic range), and the con-
straints it places on the system it is used in such as size and
power usage. In previous work [18] we studied some of the
trade-offs possible between performance and computational
cost in the Spatial AI sub-problem of real-time tracking.
One type of visual sensor which is particularly promising
for Spatial AI is known as the event camera. This is a sensor
which instead of capturing a sequence of full image frames
as a standard video camera does, only records and transmits
changes in intensity. The output of the sensor is a stream
of ‘events’ from the independently sensitive analogue pix-
els, each with pixel coordinates and an accurate timestamp.
The principle is that the event stream encodes the content of
video at a much lower bit-rate, while offering advantages in
time temporal and intensity sensitivity, and it has recently
been demonstrated (e.g. [23]) that SLAM algorithms can be
formulated which estimate camera motion, scene intensity
and depth from only the event stream.
The event camera is surely only the starting point for
coming rapid changes in image sensor technology, where
low power computer vision will be an increasingly impor-
tant driver. We can expect a full generalisation of the con-
cept of the event camera to sensors which perform signiﬁ-
cant processing of intensity data as part of the sensing pro-
cess itself, and will communicate with a main processor in
a bidirectional manner in an abstracted form which is very
different from sensing raw video streams.
Figure 1. The SCAMP5 architecture for integrated visual sensing
and processing (Figure taken from Martel and Dudek [32], and
reproduced courtesy of the authors.)
One signiﬁcant ongoing academic project in this space is
the SCAMP series of vision chips with in-plane processing
from the University of Manchester (see [32] for an intro-
duction), and Figure 1 taken from that paper. The SCAMP5
chip runs at 1.2W and has an image resolution of 256×256,
with each pixel controlled by and processable by per-pixel
processing. Using analog current-mode circuits, summa-
tion, subtraction, division, squaring, and communication
of values with neighbouring pixels can be achieved ex-
tremely rapidly and efﬁciently to permit a signiﬁcant level
of real-time vision processing completely on-chip. Ultra-
low power operation can alternatively already be achieved
in applications where low update rates are sufﬁcient.
As we will discuss later on, the range of vision process-
ing which could eventually be performed by such an image
plane processor is still be to fully discovered. The obvious
use is in front-end pre-processing such as feature detection
or local motion tracking. We believe that the longer term
potential is that while a central processor will be required
for full model-based Spatial AI, close-to-sensor processing
can interact fully with this via two-way low communication,
with the main aim of reducing the bit-rate needed between
the sensor and main processor and therefore the communi-
cation power requirements.
Finally, when considering the evolution of the comput-
ing resources for Spatial AI, we should never forget that,
cloud computing resources will continue to expand in ca-
pacity and reduce in cost. All future Spatial AI systems will
likely be cloud-connected most of the time, and from their
point of view the processing and memory resources of the
cloud can be assumed to be close to inﬁnite and free. What
is not free is communication between an embedded device
and the cloud, which can be expensive in power terms, par-
ticularly if high bandwidth data such as video is transmitted.
The other important consideration is the time delay, typi-
cally of signiﬁcant fractions of a second, in sending data to
the cloud for processing.
The long term potential for cloud-connected Spatial AI
is clearly enormous. The vision of Richard Newcombe, Di-
rector of Research Science at Oculus, is that all of these
devices should communicate and collaborate to build and
maintain shared a ‘machine perception map’ of the whole
world. The master map will be stored in the cloud, and in-
dividual devices will interact with parts of it as needed. A
shared map can be much more complete and detailed than
that build by any individual device, due to both sensor cov-
erage and the computing resources which can be put into it.
A particularly interesting point is that the Spatial AI work
which each individual device needs to do in this setup can
in theory be much reduced. Having estimated its location
within the global map, it would not need to densely map
or semantically label its surrounding if other devices had
already done that job and their maps could simply be pro-
jected into its ﬁeld of view. It would only need to be alert
for changes, and in turn play its part in returning updates.
4. High Level Design
We now turn more speciﬁcally to a design for the archi-
tecture of a Spatial AI device. Despite the clear potential for
cloud-connected shared mapping, here we choose to focus
purely on a single device which needs to operate in a space
with only on-board resources, because this is the most gen-
erally capable setup which could be useful in any applica-
tion and not require additional infrastructure.
The ﬁrst thing to consider in the design of our hypothet-
ical future Spatial AI system is what it will be required to
do:
1. Our system will comprise one or more cameras, and
supporting sensors such as an IMU, closely integrated
with a processing architecture in a small, low power
package which is embedded in a mobile entity such as
a robot or AR system. While much can be achieved
in SLAM and vision with a single camera as the only
sensor, it is clear that most practical applications will
observe their surroundings with multiple cameras and
support this with other appropriate sensors. For in-
stance, a future household robot is likely to have navi-
gation cameras which are centrally located on its body
and specialised extra cameras, perhaps mounted on its
wrists to aid manipulation.
2. In real-time, the system must maintain and update a
world model, with geometric and semantic informa-
tion, and estimate its position within that model, from
primarily or only measurements from its on-board sen-
sors.
3. The system should provide a wide variety of task-
useful information about ‘what’ is ‘where’ in the
scene.
Ideally, it will provide a full semantic level
model of the identities, positions, shapes and motion
of all of the objects and other entities in the surround-
ings.
4. The representation of the world model will be close to
metric, at least locally, to enable rapid reasoning about
arbitrary predictions and measurements of interest to
an AI or IA system.
5. It will probably retain a maximum quality representa-
tion of geometry and semantics only in a focused man-
ner; most obviously for the part of the scene currently
observed and relevant for near-future interaction. The
rest of the model will be stored at a hierarchy of resid-
ual quality levels, which can be rapidly upgraded when
revisited.
6. The system will be generally alert, in the sense that
every incoming piece of visual data is checked against
a forward predictive scene model: for tracking, and for
detecting changes in the environment and independent
motion. The system will be able to respond to changes
in its environment.
The next element of our high level thinking is to identify the
core ways that we can achieve all of this with high perfor-
mance but low power requirements.
We believe that the key to efﬁcient processing in Spatial
AI is to identify the graphs of computation and data move-
ment in the algorithms required, and as far as possible to
make use of or design processing hardware which has the
same properties, with the particular goal of minimising data
movement around the architecture. We need to identify the
following things: What is stored where? What is processed
where? What is transmitted where, and when?
We will not attempt here to draw strong parallels with
neuroscience, but clearly there is much scope for relating
the ideas and designs we discuss here in artiﬁcial Spatial AI
systems with the vision and spatial reasoning capabilities
and structures of biological brains. The human brain ap-
parently achieves high performance, fully ‘embedded’ se-
mantic and geometric vision using less than 10 Watts of
power, and certainly its structures have properties which
mirror some of the concepts we discuss. We will leave it
to other authors to analyse the relationships further; this is
mostly due to our lack of expertise in neuroscience, but also
partly due to a belief that while artiﬁcial vision systems
clearly still have a great deal to learn from biology, they
need not be designed to replicate the performance or struc-
ture of brains. We we consider the Spatial AI computation
problem purely from the engineering point of view, with
the goal of achieving the performance we need for applica-
tions while minimising resources. It should surely not be
surprising that some aspects of our solutions should mimic
those discovered by biological evolution, while in other re-
spects we might ﬁnd quite different methods due to two con-
trasts: ﬁrstly between the incremental ‘has to work all of the
time’ design route of evolution and the increased freedom
we have in AI design; and secondly between the wetware
and hardware available as a computational substrate.
5. Graphs in SLAM
SLAM and the wider Spatial AI problem have some im-
mediately apparent graph structures built into them. We will
here aim to identify and discuss these.
5.1. Geometrical Graphs
There are well known graphs which emerge naturally
from the geometry of cameras and 3D spaces and the data
which represents these.
5.1.1
Image Graph
First, there is the regular, usually rectangular geometry of
the pixels which make up the image sensor of a camera.
While each of these pixels is normally independently sensi-
tive to light intensity, many vision algorithms make use of
the fact that the output of nearby pixels tends to be strongly
correlated. This is because nearby pixels often observe parts
of the same scene objects and structures. Most commonly,
a regular graph in which each pixel is connected to its four
(up, down, left, right) neighbours is used as the basis for
smoothing operations in many early vision problems such
as dense matching or optical ﬂow estimation (e.g. [44]).
The regular graph structure of images is also taken ad-
vantage of by the early convolutional layers of CNNs for
all kinds of computer vision tasks. Here the multiple levels
of convolutions also acknowledge the typical hierarchical
nature of local regularity in image data.
5.1.2
Map Graph
The other clear geometrical graph present in Spatial AI
problems is in the maps or models which are built and main-
tained of an environment by SLAM systems. This graph
structure has been recognized and made use of by many im-
portant SLAM methods (e.g. [22, 26, 49, 12, 35]).
As a camera moves through and observes the world, a
SLAM algorithm detects, tracks and inserts into its map fea-
tures which are extracted from the image data. (Note that
we use the word ‘feature’ here in a general sense to mean
some abstraction of a scene entity, and that we are not con-
ﬁning our thinking to sparse point-like landmarks.) Each
feature in the scene has a region of camera positions from
which it is measurable. A feature will not be measurable if
it is outside of the camera’s ﬁeld of view; if it is occluded;
or for other reasons such that its distance from the camera
or angle of observation are very different from when it was
ﬁrst observed.
This means that as the camera moves through a scene,
features become observable in variable overlapping pat-
terns. As measurements are made of the currently visible
features, estimates of their locations are improved, and the
measurements are also used to estimate the camera’s mo-
tion. The estimates of the locations of features which are
observed at the same time become strongly correlated with
each other via the uncertain camera state. Features which
are ‘nearby’ in terms of the amount of camera motion be-
tween observing them are still correlated but somewhat less
strongly; and features which are ‘distant’ in that a lot of mo-
tion (and SLAM based on intermediate features) happens
between their observation are only weakly correlated.
The probabilistic joint density over feature locations
which is the output of SLAM algorithms can be efﬁciently
represented by a graph where ‘nearby’ features are joined
by strong edges, and ‘distant’ ones by weak edges.
A
threshold can be chosen on the accuracy of probabilistic
representation which leads to the cutting of weaker edges,
and therefore a sparse graph where only ‘nearby’ features
are joined.
One way to do SLAM is not to explicitly estimate the
state of scene features, but instead to construct a map of a
subset of the historical poses that the moving camera has
been in, and to keep the scene map implicit. This is usually
called pose graph SLAM, and within this kind of map the
graph structure is obvious because we join together poses
between which we have been able to get sensor correspon-
dence. Poses which are consecutive in time are joined; and
poses where we are able to detect a revisit after a longer pe-
riod of time are also joined (this is called a loop closure).
Whether the graph is of historic poses, or of scene fea-
tures, its structure is very similar, in that it connects either
‘nearby’ poses or the features measured from those poses,
and there is not a fundemental difference between the two
approaches.
A property of a passive camera which is different from
other sensors is that it has effectively inﬁnite range. It can
see objects which are very close in exquisite detail; but also
observe objects which are extremely far away. Visual maps
will consist of all of these things, and this is why we have
not been precise so far with the concepts of ‘nearby’ and
‘distant’. The locality in visual maps is not a matter of sim-
ple metric distance. Remembering that what is important
is how feature position estimates become correlated due to
camera motion and measurements, a SLAM graph will have
a multi-scale character, such that elements measured from a
close camera (the different objects on a table) may form a
signiﬁcant interconnected chunk of a graph, while another
similar chunk contains much more separated elements seen
from farther away (a group of buildings on the other side of
the city).
This leads us to conclude that the most likely represen-
tation for Spatial AI is to represent 3D space by a graph of
features, which are linked in multi-scale patterns relating to
camera motion and together are able of generating dense
scene predictions.
Chli and Davison [5] investigated an automatic way
to discover the hierchical graph structure of a feature-
based map by analysing correlations purely in measurement
space, and it is clear that relating such a structure quite
closely to a co-visibility keyframe graph gives a similar re-
sult. However, this work was based on standard point fea-
tures. We have not yet discovered a suitable feature repre-
sentation which describes both local appearance and geom-
etry in such a way that a relatively sparse feature set can
provide a dense scene prediction. We believe that learned
features arising from ongoing geometric deep learning re-
search will provide the path towards this.
Some very promising recent work which we be-
lieve is heading in the right direction Bloesch et al.’s
CodeSLAM [3]. This method uses an image-conditioned
autoencoder to discover an optimisable code with a small
number of parameters which describes the dense depth map
at a keyframe. In SLAM, camera poses and these depth
codes can be jointly optimised to estimate dense scene
shape which is represented by relatively few parameters. In
this method, the scene geometry is still locked to keyframes,
but we believe that the next step is to discover learned codes
which can efﬁciently represent both appearance and 3D
shape, and to make these the elements of a graph SLAM
system.
5.1.3
Image/Model Correspondence
Let us go a little deeper into this idea, and in particular to
understand that as a camera moves through the world, the
contact or correspondence between its image graph and its
map graph will change, continuously and dynamically, in a
way which can be very rapid but is not random. What does
this mean for the computational structures we should use in
Spatial AI?
Fundamentally, in a SLAM process we cannot pre-
compute the shape of the map that will be built, because
it depends on the motion of the camera. However, perhaps
we can have a generic structure which is representative of
many types of motion, ready to be ﬁlled when needed as a
space is explored. What is important in graph maps, from
a computational point of view, is topology: which things
are connected to which others, and in which patterns. Maps
with hierarchical topologies in regular space such as multi-
scale occupancy grids or heightmaps have been developed
(e.g. [57, 60]), and these enable efﬁcient mapping in sys-
tems where localisation can be separated and assumed to
be good. In general visual SLAM, the graph needs a ﬂexi-
ble structure, which is multiscale but can also be adapted at
loop closure, and there are still good questions about how to
design the ideal container. Experiments could be performed
with current dense SLAM systems to determine the typical
patterns of correlation between surface elements in various
applications.
5.2. Computation Graph
The other key type of graph which we can easily identify
in Spatial AI problems is in the computation which takes
place in a SLAM system’s real-time loop.
We make a hypothesis that the core computation graph
for the tightest real-time loop of future SLAM systems will
have many elements which are familiar with today’s sys-
tems. Speciﬁcally the Dense SLAM paradigm introduced
by Newcombe et al. [39, 41, 42] is at the centre of this in
our view, because this approach aims to model the world in
dense, generative detail such that every new pixel of data
from a camera can be compared against a model-based pre-
diction. This allows systems which are generally ‘aware’,
since as they continually model the state of the world in
front of the camera, they can detect when something is out
of place with respect to this model, and therefore dense
SLAM systems are now being developed which are mov-
ing beyond static scenes to reconstruct and track dynamic
scenes [40, 47]. Dense SLAM systems can also make the
best possible use of scene priors, which will increasingly
come from learning rather than being hand-designed.
Following some of these arguments, Newcombe et al.’s
KinectFusion algorithm [41] was chosen as the basis for
the ﬁrst version of the SLAMBench framework [38] which
aimed to provide a forward looking benchmark for the com-
putational properties of SLAM systems. Since KinectFu-
sion, dense SLAM has been augmented with semantic la-
belling in systems like SemanticFusion [33], which uses the
surfel-based and loop closure-capable ElasticFusion [56] as
its dense SLAM basis. As well as being used for SLAM,
incoming image and depth frames are fed to a CNN which
has been pre-trained for per-pixel semantic labelling into
thirteen classes typical of domestic scenes, such as wall,
ﬂoor, table, chair or bed. The output for each pixel is a dis-
tribution over possible labels, and these are then projected
onto the 3D SLAM map, where each surfel maintains and
updates a label probability distribution via Bayesian fusion.
As we discussed before, a goal of this line of research
is to get to a general SLAM system which has the ability
to identify and estimate the locations of all of the objects
in a scene, in the style demonstrated in a prototype way
by SLAM++ [49] which made efﬁcient maps directly at the
level of objects in precise 3D poses, but could only deal with
a small number of speciﬁc object types. How can we get
back to this ‘object-oriented SLAM’ capability in the much
Figure 2. Some elements of the Spatial AI real-time computation graph.
more general sense, where a wide range of object classes of
varying style and details could be dealt with? As discussed
before, SLAM maps of the future will probably be repre-
sented as multi-scale graphs of learned features which de-
scribe geometry, appearance and semantics. Some of these
features will represent immediately recognised whole ob-
jects as in SLAM++. Others will represent generic seman-
tic elements or geometric parts (planes, corners, legs, lids?)
which are part of objects either already known or yet to
be discovered. Others may approach surfels or other stan-
dard dense geometric elements in representing the geometry
and appearance of pieces whose semantic identity is not yet
known, or does not need to be known.
Recognition, and unsupervised learning, will operate on
these feature maps to cluster, label and segment them. The
machine learning methods which do this job will them-
selves improve by self-supervision during the SLAM pro-
cess, taking advantage of dense SLAM’s properties as a
‘correspondence engine’ [50].
From a starting point of the algorithmic analysis of the
KinectFusion algorithm in SLAMBench [38], we make an
attempt at drawing a computation graph for a generally ca-
pable future Spatial AI system in Figure 2.
Most computation relates to the world model, which is a
persistent, continuously changing and improving data store
where the system’s generative representation of the impor-
tant elements of the scene is held; and the input camera data
stream. Some of the main computational elements are:
• Empirical labelling of images to features (e.g. via a
CNN).
• Rendering: getting a dense prediction from the world
map to image space.
• Tracking: aligning a prediction with new image data,
including ﬁnding outliers and detecting independent
movement.
• Fusion: fusing updated geometry and labels back into
the map.
• Map consolidation: fusing elements into objects, or
imposing smoothing, regularisation.
Figure 3. Graphcore’s Poplar graph compiler turns the speciﬁca-
tion of an algorithm from a framework such as TensorFlow into a
deﬁnition of the computation graph which is suitable for efﬁcient
distributed deployment on their IPU graph processor. This is a vi-
sualisation of the result for the AlexNet image classiﬁcation CNN,
supporting both training and run-time operation, where the spatial
conﬁguration and colouring indicates close connectivity of the dif-
ferent processing modules required. Image courtesy of Graphcore.
• Relocalisation/loop closure detection: detecting self
similarity in the map.
• Map consistency optimisation, for instance after con-
ﬁrming a loop closure.
• Self-supervised learning of correspondence informa-
tion from the running system.
In the following sections we will think about where these
data and computational elements might operate in future ar-
chitectures.
6. Main Map Processing; Representation, Pre-
diction and Update
We explained that in the overall architecture of our Spa-
tial AI computation system, the long term key to efﬁcient
performance is to match up the natural graph structures of
our algorithms to the conﬁguration of physical hardware.
As we have seen, this reasoning leads to the use of ‘close to
the sensor’ processing such as in-plane image processing,
and the attempt to minimise data transfer from sensors and
towards actuators or other outputs using principles such as
events.
However, we still believe that the bulk of computation in
an embedded Spatial AI system is best carried out by a rel-
atively centralised processing resource. The key reason for
Map Store
Real-Time Loop
Camera Interfaces
Sensor Interface
Actuator Interface
Camera Processors
Figure 4. Spatial AI brain: an imagining of how the representa-
tion and processing graph structures of a general Spatial AI sys-
tem might map to a graph processor. The key elements we identify
are the real-time processing loop, the graph-based map store, and
blocks which interface with sensors and output actuators. Note
that we envision additional ‘close to the sensor’ processing built
into visual sensors, aiming to reduce the data bandwidth (eventu-
ally in two directions) between the main processor and cameras,
which will generally be located some distance away.
this is the essential and ever-present role of an incremen-
tally built and used world model representing the system’s
knowlege of its state and that of its environment. Every new
piece of data from possibly multiple cameras and sensors is
ultimately compared with this model, and either used to up-
date it or discarded if the data is not relevant to device’s
short or long-term goals.
What we are anticipating for this central processing re-
source is however far from the model of a CPU and RAM-
like memory store. A CPU can access any contents of its
RAM with a similar cost, but in Spatial AI there is much
more structure present, as we saw in Section 5, both in the
locality of the data representing knowledge of the world
(5.1), and in the organisation of the computation workload
involved in incorporating new data (5.2).
The graph structures of processing and storage should
be built into the design of the central world model compu-
tation unit, which should combine storage and processing in
a fully integrated way. There are already signiﬁcant efforts
on new ways to design architectures which are explicitly
and ﬂexibly graphlike.
To focus on one processor architecture currently under
development, Graphcore’s IPU or graph processor is de-
signed to efﬁciently carry out AI workloads which are well
modelled as operations on sparse graphs, and in particular
when all of the required storage is itself also held within the
same graph rather than in an external memory store. An IPU
chip has a large number of independent cores (in the thou-
sands), each of which can run its own arbitrary program and
has its own local memory store, and then a powerful com-
munication substrate such that the cores can efﬁciently send
messages between themselves. When a program is to be run
on the IPU, it is ﬁrst compiled into a suitable form by anal-
ysis of the patterns of computation and communication it
requires. A suitable graph topology of optimised locations
of operations, data, and channels of communication is gen-
erated.
Graphcore have so far concentrated on how the IPU can
be used to implement deep neural networks, both at train-
ing time and runtime. Figure 3 is a visualisation of the graph
structure identiﬁed by their graph compiler Poplar from the
TensorFlow deﬁnition of a standard CNN for image classi-
ﬁcation. Starting from a neuron’s elemental computations
of multiplying activations by weights, adding them together
and passing the result through a non-linearity, they build up
a processing graph which deﬁnes how these computations
are joined together by data inputs and outputs. When this
very detailed graph is visualised at increasing scale, with a
view which ‘zooms out’, clusters of highly interlinked oper-
ations are apparent and these are concentrated and coloured
in the visualisation, and the whole graph is mapped to a
disc. The result is appealingly ‘brain-like’, with the vari-
ous layers of the network shown as blocks of different sizes
with their own internal structure visible. It it important to
note that this computational structure represents the oper-
ations of both training the CNN and using it for runtime
operation.
Graphcore believe that the IPU will already have per-
formance beneﬁts for executing well known deep neural
networks compared to GPUs, and their initial product of-
fering will be an accelerator card for machine learning in
the cloud. However, their vision is greater than this, and
they say that the advantages of an IPU will become greater
and greater as the complexity of models increases. Accord-
ing to CEO Nigel Toon: ‘the end game is deep, wide rein-
forcement learning, or more simply, building networks that
improve with use’, thinking towards recurrent, self-training
structure with memory and constant input and output of
data. Clearly this is very well aligned with the vision we
have for the future of SLAM and Spatial AI, where we
imagine systems with a complex pattern of designed and
learned modules, communicating in real-time with input
sensors and output actuators, and learning and improving
their internal representations continuously.
In Figure 4 we have made a ﬁrst attempt at drawing a
‘Spatial AI brain’ model which is somehow analagous to
Graphcore’s visualisations. The disc contains the modules
we anticipate running inside the main processor. One of the
two main areas is the map store, which is where the current
world model is stored. This has an internal graph structure
relating to the geometry of the world. It will also contain
signiﬁcant internal processing capability to operate locally
on the data in the model, and we will discuss the role of
this shortly. The second main area is the real-time loop,
which is where the main real-time computation connecting
the input image stream to the world model is carried out.
This has a processing graph structure and must support large
real-time data ﬂows and parallel computation on image/map
structures so is designed to optimise this.
The main processor also has additional modules. There
are camera interfaces, the job of each of which is to model
and predict the data arriving at the sensor to which it is con-
nected. This will then be connected to the camera itself,
which the physical design of a robot or other device may
force to be relatively far from the main processor. The con-
nection may be serial or along multiple parallel lines.
We then imagine that each camera will have its own
‘close-to-sensor’ processing capability built in, separated
from the main processor by a data link.
The goal of
modelling the input within the main processor is to min-
imise actual data transfer to the close-to-sensor proces-
sors. It could be that the close-to-sensor processor performs
purely image-driven computation, in a manner similar to
the SCAMP project, and delivers an abstracted representa-
tion to the main processor. Or, there could be bi-directional
data transmission between the camera and main processor.
By sending model predictions to the close-to-sensor proces-
sors, they know what is already available in the main pro-
cessor and should report only differences. This is a generali-
sation of the event camera concept. An event camera reports
only changes in intensity, whereas a future optimally efﬁ-
cient camera should report places where the received data
is different from what was predicted. We will discuss close-
to-sensor processing further in Section 7.
6.1. Map Store
There is a large degree of choice possible in the represen-
tation of a 3D scene, but as explained in Section 5.1.2, we
envision maps which consist of graphs of learned features,
which are linked in multi-scale patterns relating to camera
motion. These features must represent geometry as well as
appearance, such that they can be used to render a dense
predicted view of the scene from a novel viewpoint. It may
be that they do not need to represent full photometric ap-
pearance, and that a somewhat abstracted view is sufﬁcient
as long as it captures geometric detail.
Within the main processor, a major area will be devoted
to storing this map, in a manner which is distributed around
potentially a large number of individual cores which are
strongly connected in a topology to mirror the map graph
topology. In SLAM, of course the map is deﬁned and grown
dynamically, so the graph within the processor must ei-
ther be able to change dynamically as well, or must be ini-
tially deﬁned with a large unused capacity which is ﬁlled as
SLAM progresses.
Importantly, a signiﬁcant portion of the processing asso-
ciated with large scale SLAM can be built directly into this
graph. This is mainly the sort of ‘maintenance’ processing
via which the map optimises and reﬁnes itself; including:
• Feature clustering; object segmentation and identiﬁca-
tion.
• Loop closure detection.
• Loop closure optimisation.
• Map regularisation (smoothing).
• Unsupervised clustering to discover new semantic cat-
egories.
With time, data and processing, a map which starts off
as dense geometry and low level features can be reﬁned to-
wards an efﬁcient object level map. Some of these opera-
tions will run with very high parallelism, as each part of the
map is reﬁned on its local core(s), while other operations
such as loop closure detection and optimisation will require
message passing around large parts of the graph. Still, im-
portantly, they can take place in a manner which is internal
to the map store itself.
The on-chip memory of next generation graph pro-
cessors like Graphcore’s IPU is fully distributed among
the processing tiles, and the total capacity will initially
not be huge (certainly when compared with standard off-
processor RAM), and therefore there should be an empha-
sis on rapidly abstracting the map store towards an efﬁcient
long-term form.
Optimising the geometric estimates in a SLAM map,
such that the metric map state is the most probably solu-
tion given the history of measurements obtained, is a very
well known optimisation problem known as Bundle Ad-
justment (BA) in computer vision or graph optimisation in
robotics. The sparse constraints between poses and features
due to measurements lead to sparsity in the solvers needed
(e.g. [25]). While BA can be interpreted in terms of matrix
operations, it is also commonly posed directly as a graph
algorithm [11], and is clearly well suited to implementation
in a message passing manner on a graph processor.
6.2. Real-Time Loop
This other major part of the graph encompasses the core
processing which operates on live data input from cameras
and other sensors and connects it to the map.
New im-
ages are tracked against projections from the map and fused
into updated representations. This is generally massively
parallel processing which is familiar from GPU-accelerated
dense SLAM systems, and these functions can be deﬁned
as ﬁxed elements in a computational graph which use a
number of nodes and access a signiﬁcant fraction of the
main computational resource. Functions such as segmenta-
tion and labelling of input images will also be implemented
here (or possibly outside of the main processor by close-to-
sensor processing).
Data from the map store is needed for rendering, when
a predicted view of the scene is needed for tracking against
new image data, and for fusion, when information (geome-
try and labels) acquired from the new data is used to update
the map contents.
The most difﬁcult issue in applying graph processing to
the real-time loop is the fact that the relevant part of the
graph-based map store for these operations changes contin-
uously due to camera motion. This seems to preclude deﬁn-
ing an efﬁcient, ﬁxed data path to the distributed memory
where map information will be stored. Although there will
be internal processing happening in the map store, this will
be focused on maintenance and it does not seem appropri-
ate to mode data rapidly around the map store, for instance
such that the currently observed part of the map is always
available in a particular graph location.
Instead, a possible solution is to deﬁne special interface
nodes which sit between the real-time loop block and the
map store. These are nodes focused on communication,
which are connected to the relevant components of real-
time loop processing and then also to various sites in the
map graph, and may have some analogue in the hippocam-
pus of mammal brains. If the map store is organised such
that it has a ‘small world’ topology, meaning that any part
is joined to any other part by a small number of edge hops,
then the interface nodes should be able to access (copy) any
relevant map data in a small number of operations and serve
them up to the real-time loop.
Each node in the map store will also have to play some
part in this communication procedure, where it will some-
times be used as part of the route for copying map data back-
wards and forwards.
7. Processing Close to the Image Plane
A robot or other device will have one or more cameras
which interface with the main processor, and we believe that
the technology will develop to allow a signiﬁcant amount of
processing to occur either within the sensors themselves or
nearby, with the key aim of reducing the amount of redun-
dant data which ﬂows from the cameras. A ﬁrst thought is
to directly attach cameras to the main processor itself, with
direct parallel connections (wires) from the pixels to mul-
tiple processing nodes, and certainly this is very appealing
and could be possible in some cases. However, it is likely
that in most devices there are good reasons why the main
processor will not be located right next to the cameras, such
as heat dissipation or space. The ideal locations for cam-
eras are unlikely to be the same as the ideal location for a
main processor. In any case, most future devices are likely
to have multiple cameras which all need to interface with
the same main processor and map store. Therefore some
long camera to main processor connections will be needed,
and this motivates additional processing in the camera itself
or very nearby.
Most straightforwardly, a sensor with in-plane process-
ing similar to SCAMP5 [32] could be used to carry out
purely bottom-up processing of the input image stream; ab-
stracting, simplifying and detecting features to reduce it to
a more compact, data-rich form. Calculations such as local
tracking (e.g. optical ﬂow estimation), segmentation and
simple labelling could also be performed.
Tracking using in-plane processing is an interesting
problem. In plane processing is good for problems where
data access can be kept very local, so estimating local image
motion (optical ﬂow), where the output is a motion vector
at every pixel, is well suited. At each update, the amount
of image change locally can be augmented using local reg-
ularisation where smoothness is applied based on the dif-
ferences of neighbouring pixels. If we look at the parallel
implementation of an algorithm like Pock’s TV-L1 optical
ﬂow [44], we see that it involves pixelwise-parallel opera-
tions, where purely parallel steps relating to the data term
alternate with regularisation steps involving gradient com-
putation, which could be achieved using message passing
between adjacent neighbours. So such an algorithm is an
excellent candidate for implementation on an in-plane pro-
cessor.
More challenging is the tracking usually required in
SLAM, where from local image changes we wish to es-
timate consistent global motion parameters relating to a
model. This could be instantaneous camera motion esti-
mation, where we wish to estimate the amount of global
rotation for instance between one frame and the next via
whole image alignment [30], or tracking against a persis-
tent scene model as in dense SLAM [29, 39]. When dense
tracking is implemented on standard processors, it involves
alternation of purely parallel steps for error term computa-
tion across all pixels with reduction steps where all errors
are summed and the global motion parameters are updated.
The reduction step, where a global model is imposed, plays
the role of regularisation, but the big difference is that the
regularisation here is global rather than local.
In a modern system, such global tracking is usually best
achieved by a combination of GPU and CPU, and there-
fore a regular (and expensive) transfer of data between the
two. But we do not have this option if we wish to use in-
plane processing and keep all computations and memory
local. Our main option for not giving up on data locality
is to give up on guaranteed global consistency of our track-
ing solution, but to aim to converge towards this via local
message passing. Each pixel could keep its own estimate
of the global motion parameters of interest, and after each
iteration share these estimates with local neighbours. We
would expect that global convergence would eventually be
reached, but that after a certain number of iteration that the
values held by each pixel could be close enough that any
single pixel could be queried for a usable estimate. Conver-
gence would be much faster if the in-plane processor also
featured some longer data-passing links between pixels, or
more generally had a ‘small world’ pattern of interconnec-
tions.
Turning to the questions of labelling using local process-
ing, this is certainly feasible but a problem with sophisti-
cated labelling is that current in plane processor designs
have very small amounts of memory, which makes it dif-
ﬁcult to store learned convolutional masks or similar.
Future processors for bottom-up processing may move
beyond operating purely in the image plane, and use a 3D
stacking approach which could be well suited to imple-
menting the layers of a CNN. Currently 3D silicon stacks
are hard to manufacture, and there are particular chal-
lenges around heat dissipation and cost, but the time will
surely come when extracting a feature hierarchy is a built-
in capability of a computer vision camera. Work such as
Czarnowski et al.’s featuremetric tracking [6] shows the
wide general use this would have. We should investigate the
full range of outputs that a single purely feed-forward CNN
to do when trained with a multi-task learning approach.
An interesting question is whether processing close to
the image plane will remain purely bottom-up, or whether
two-way communication between cameras and the main
processor will be worthwhile. This would enable model
predictions from the world map to be delivered to the cam-
era at some rate, and therefore for higher level processing
to be carried out there such as model-based tracking of the
camera’s own motion or known objects.
In the limit, if a fully model-based prediction is able to
be communicated to the camera, then the camera need only
return information which is different from the prediction.
This is in some sense a limit of the way that an event camera
works. An event camera outputs data if a pixel changes in
brightness — which is like assuming that the default is that
the camera’s view of the scene will stay the same. A general
‘model-based event camera’ will output data if something
happens which differs from its prediction. These questions
come down to key issues of ‘bottom-up vs. top-down’ pro-
cessing, and we will consider them further in the next sec-
tion.
As a ﬁnal note here, any Spatial AI system must ul-
timately deliver a task-determined output. This could be
the commands sent to robot actuators, communication to be
sent to another robot or annotations and displays to be sent
to a human operator in an IA setting. Just as ‘close to the
sensor’ processing is efﬁcient, there should alse be a role for
‘close to the actuator’ processing, particularly because ac-
tuators or communication channels have their own types of
sensing (torque feedback for actuators; perhaps eye track-
ing or other measures for an AR display) which need to be
taken account of and fused in tight loops.
8. Attention Mechanisms, or the Return of Ac-
tive Vision
The active vision paradigm [2] advocates using sensing
resources, such as the directions that a camera points to-
wards or the processing applied to its feed, in a way which
is controlled depending on the task at hand and prior knowl-
edge available. This ‘top-down’ approach contrasts with
‘bottom-up’, blanket processing of all of the data received
from a camera.
In Davison’s ‘Active Search for Real-Time Vision’ the
argument was made that image processing in tracking and
SLAM can be greatly reduced via prediction and active
search [9]. Image features need not be detected ‘bottom
up’ across every frame, but their positions predicted based
on a model and searched for in a focused manner.
The
problem with this idea was that while image processing
operations can certainly be saved by prediction and active
search, too much computation is required to decide where
to look. Most successful real-time vision systems since this
time have instead used a ‘brute force’ approach to low level
image processing. In SLAM, this has meant either full-
frame detection of simple features (e.g. FAST features [46]
as in PTAM [24]), or dense whole-image tracking as (e.g.
DTAM [42]). The probabilistic calculations in [9] were se-
quential, and in particular difﬁcult to transfer to the parallel
architectures taken advantage of by [24] or [42].
Biological vision has a combination of bottom-up pro-
cessing (early vision, which seems to operate in a purely
bottom-up manner), and active, or top-down vision (proven
by our moving heads and eyes which seek out relevant in-
formation for tasks based on model predictions). We believe
that an active vision approach will return to real-time com-
puter vision, but at a higher level than raw pixels. In partic-
ular, the ﬂexibility of graph processing architectures will be
much more amenable to active processing than CPU/GPU
systems.
We understand very well now that entirely bottom-up
processing of an image or short sequence, via a CNN for
example, can achieve remarkable things such as semantic
labelling, object detection, depth estimation and local mo-
tion estimation. At what level though should we interrupt
this processing to bring in model-based predictions or task-
dependent requirements? For instance, is it necessary to
apply generic object detection processing to every image
frame, when we can project previously mapped 3D objects
into the newly estimated camera pose, and then apply any
detection effort only to image areas so far unexplained by
good object models (as shown by SLAM++ [49])? The big
question is: What is the range of processing that we should
expect a purely bottom-up algorithm to perform on input
before it interacts with model-based data, predictions, and
optimisation?
The answer to this question must come back to the same
kind of information gain versus computation arguments
which were used in [9], but now considered more broadly.
That paper studied low level feature matching in the con-
text of a model-based prediction (such as in incrememtal
probabilistic SLAM), and showed that the amount of im-
age processing required to match a set of features could
be much reduced by a one-by-one search strategy. Each
search reduced the total model uncertainty, and therefore
also the size of the search regions for the other features and
the computation needed to match them. The order of search
required was determined based on calculation of mutual in-
formation: the expected reduction in uncertainty for each
candidate measurement. The problem with this method was
that the reduction in image processing was ultimately out-
weighed by the extra computation needed to make the prob-
abilistic and information theoretic calculations about what
to measure next. In the end the elemental image processing
computations needed to match point features are not expen-
sive enough to make active search worthwhile, and it turns
out to be better simply to detect and match all features.
But as we reach towards full scene understanding from
vision in real-time, with the higher computational load re-
quired by elements such as dense reconstruction, segmen-
tation or recognition, active choices will make sense again.
Consider a simple possible bottom-up processing pipeline
for semantic vision:
1. Localisation using sparse features.
2. Dense reconstruction.
3. Pixel-wise scene labelling.
4. Object instance segmentation.
5. 3D object model ﬁtting.
In analysis, we can estimate the per-pixel computational
cost of each of these elements as part of the pipeline, and
assess the quality of their output. These measure should
then be compared with the alternative ‘predict-update’ pro-
cedure, which could be carried out at any of the levels of
output.
Here we recover existing models from memory,
warp them based on updates at the lower levels to make pre-
dictions for the current time-step, and then use ‘fusion’ pro-
cessing on this together with the new image to update and
augment the predictions into a ﬁnal output. Computation
should be focused on ﬁlling in not yet modelled regions,
such as new parts of the scene which come into view at the
edges of images or are revealed as occlusions are passed,
or improving the estimates of regions where estimates have
high uncertainty, such as those seen in more detail when ap-
proached or observed in improved lighting. This ‘improve-
ment’ will usually take the form of a probabilistic optimisa-
tion, where a weighted combination is made of model-based
predictions and information from the new data.
It is important that when assessing the relative efﬁciency
of bottom-up versus top-down vision, we take into account
not just processing operations but also data transfer, and to
what extent memory locality and graph-based computation
can be achieved by each alternative. This will make certain
possibilities in model-based prediction unattractive, such as
searching large global maps or databases. The amazing ad-
vances in CNN-based vision means that we have to raise
our sights when it comes to what we can expect from pure
bottom-up image processing. But also, graph processing
will surely permit new ways to store and retrieve model
data efﬁciently, and will favour keeping and updating world
models (such as graph SLAM maps) which have data local-
ity.
9. Performance Metrics and Evaluation
One of the hypotheses we made at the start of this paper
is that the usefulness of a Spatial AI system for a wide range
of tasks is well represented by a relatively small number of
performance measures which have general importance.
The most common focus in performance measurement in
SLAM is on localisation accuracy, and there have been sev-
eral efforts to create benchmark datasets for this (e.g. [52]).
An external pose measurement from a motion capture sys-
tem is considered as the ground truth against which a SLAM
algorithm is compared.
We have argued that Spatial AI is about much more
than pose estimation, and more recent datasets have tried
to broaden the scope of what can be evaluated. Dense scene
modelling is difﬁcult to evaluate because it requires an ex-
pensive and time-consuming process such as detailed laser
scanning to capture a complete model of a real scene which
is accurate and complete enough to be considered ground
truth. The alternative, for this and other axes of evalua-
tion, is to generate synthetic test data using computer graph-
ics, such as the ICL-NUIM dataset [19]. Recently this ap-
proach has been extended also to provide ground truth for
semantic labelling (e.g. SceneNet RGB-D [34]), another
output where it is difﬁcult to get good ground truth for real
data. It is natural to be suspicious of the value of evalua-
tion against synthetic test data, and there are many new ap-
proaches to gathering large scale real mapping data, such as
crowdsourcing (e.g. ScanNet [7]). However, synthetic data
is getting better all the time and we believe will only grow
in importance.
Stepping back to a bigger point, we can question the
value of using benchmarks at all for Spatial AI systems. It
is an often heard comment that computer vision researchers
are hooked on dataset evaluation, and that far too much
effort has been spent on optimising and combining algo-
rithms to achieve a few more percentage points on bench-
marks rather than working on new ideas and techniques.
SLAM, due to its real-time nature, and wide range of use-
ful outputs and performance levels for different applica-
tions, has been particularly difﬁcult to capture by meaning-
ful benchmarks. I have usually felt that more can be learned
about the usefulness of a visual SLAM system by play-
ing with it for a minute or so, adaptively and qualitatively
checking its behaviour via live visualisations, than from
its measured performance against any benchmark available.
Progress has therefore been more meaningfully represented
by the progress of high quality real-time open source SLAM
reseach systems (e.g.
MonoSLAM [8, 10], PTAM [24],
KinectFusion [41], LSD-SLAM [12], ORB-SLAM [36],
OKVIS [28], SVO [14], ElasticFusion [56]) that people can
experiment with, rather than benchmarks.
Benchmarks for SLAM have been unsatisfactory be-
cause they make assumptions about the scene type and
shape, camera and other sensor choices and placement,
frame-rate and resolution, etc., and focus in on certain eva-
lution aspects such as accuracy while downplaying other
arguably more important ones such as efﬁciency or ro-
bustness. For instance, many papers evaluating algorithms
against accuracy benchmarks make choices among the test
sequences available in a dataset such as [52] and report per-
formance only on those where they basically ‘work’.
This brings us to ask whether we should build bench-
marks and aim to evaluate and compare SLAM systems at
all? We still argue yes, but the focus on broadening what
is meant by a benchmark for a Spatial AI system, and an
acknowledgement that we should not put too much faith in
what they tell us.
The SLAMBench framework released by the PAMELA
research project [38] represents important initial work on
looking at the performance of a whole Spatial AI system.
In SLAMBench, a SLAM algorithm (speciﬁcally KinectFu-
sion [41]) is measured in terms of both accuracy and com-
putational cost across a range of processor platforms and us-
ing different language implementations. SLAMBench2 [4],
recently released, now allows a a wide range of SLAM al-
gorithms to be compared within a uniﬁed test framework,
and other work in the PAMELA project is broadening this
effort in other directions. Saeedi et al. [48] have for instance
started to address the issue of quantifying the SLAM chal-
lenge represented by the type of motion and typical scene
geometry and appearance which is present in particular ap-
plications. The motion of wearable devices, ground robots
and drones are all very different, and they are required to
work in different environments. While SLAM on a drone
is certainly challenging due to rapid motion, a small ground
robot can also be a difﬁcult case because of the low tex-
ture available in many indoor environments and its position
close to the ground where there are many occlusions.
Over the longer term, we believe that benchmarking
should move towards measures which have the general abil-
ity to predict performance on tasks that a Spatial AI might
need to perform. This will clearly be a multi-objective set
of metrics, and analysis of Pareto fronts [37] will permit
choices to be made for a particular application.
A possible set of metrics includes:
• Local pose accuracy in newly explored ares (visual
odometry drift rate).
• Long term metric pose repeatability in well mapped
areas.
• Tracking robustness percentage.
• Relocalisation robustness percentage.
• SLAM system latency.
• Dense distance prediction accuracy at every pixel.
• Object segmentation accuracy.
• Object classiﬁcation accuracy.
• AR pixel registration accuracy.
• Scene change detection accuracy.
• Power usage.
• Data movement (bits×millimetres).
10. Conclusions
To conclude, the research area of Spatial AI and SLAM
will continue to gain in importance, and evolve towards the
general 3D perception capability needed for many different
types of application with the full fruition of the combina-
tion of estimation and machine learning techniques. How-
ever, wide use in real applications will require this advance
in capability to be accompanied by driving down the re-
sources required, and this needs joined-up thinking about
algorithms, processors and sensors. The key to efﬁcient sys-
tems will be to identify and design for sparse graph patterns
in algorithms and data storage, and to ﬁt this as closely as
possible to the new types of hardware which will soon gain
in importance.
Acknowledgements
This paper represents my personal opinions and mus-
ings, but has beneﬁtted greatly from many discussions and
collaborations over recent years. In particular I would like
to thank all of my collaborators on the PAMELA Project
funded by EPSRC Grant EP/K008730/1, especially Paul
Kelly, Steve Furber, Mike O’Boyle, Mikel Luj´an, Bj¨orn
Franke, Graham Riley, Zeeshan Zia, Sajad Saeedi, Luigi
Nardi, Bruno Bodin, Andy Nisbet and John Mawer.
I am also grateful to my other colleagues at the Dyson
Robotics Lab at Imperial College, the Robot Vision Group,
SLAMcore, Dyson, and elsewhere with whom I have dis-
cussed many of these ideas; especially Stefan Leutenegger,
Jacek Zienkiewicz, Owen Nicholson, Hanme Kim, Charles
Collis, Mike Aldred, Rob Deaves, Walterio Mayol-Cuevas,
Pablo Alcantarilla, Richard Newcombe, David Moloney,
Simon Knowles, Julien Martel, Piotr Dudek and Matthew
Cook.
References
[1] SLAMcore. URL http://www.slamcore.com/, 2018. 2
[2] D. H. Ballard.
Animate Vision.
Artiﬁcial Intelligence,
48:57–86, 1991. 15
[3] M. Bloesch, J. Czarnowski, R. Clark, S. Leutenegger, and
A. J. Davison.
CodeSLAM — learning a compact, opti-
misable representation for dense visual SLAM. In Proceed-
ings of the IEEE Conference on Computer Vision and Pattern
Recognition (CVPR), 2018. 9
[4] B. Bodin, H. Wagstaff, S. Saeedi, L. Nardi, E. Vespa, J. H.
Mayer, A. Nisbet, M. Luj´an, S. Furber, A. J. Davison, P. H. J.
Kelly, and M. O’Boyle.
SLAMBench2: Multi-objective
head-to-head benchmarking for visual SLAM. In Proceed-
ings of the IEEE International Conference on Robotics and
Automation (ICRA), 2018. 1, 16
[5] M. Chli and A. J. Davison. Automatically and Efﬁciently
Inferring the Hierarchical Structure of Visual Maps. In Pro-
ceedings of the IEEE International Conference on Robotics
and Automation (ICRA), 2009. 9
[6] J. Czarnowski, S. Leutenegger, and A. J. Davison. Semantic
texture for robust dense tracking. In Proceedings of the In-
ternational Conference on Computer Vision Workshops (IC-
CVW), 2017. 14
[7] A. Dai, A. X. Chang, M. Savva, M. Halber, T. Funkhouser,
and M. Nießner. ScanNet: Richly-annotated 3d reconstruc-
tions of indoor scene. In Proceedings of the IEEE Confer-
ence on Computer Vision and Pattern Recognition (CVPR),
2017. 16
[8] A. J. Davison.
Real-Time Simultaneous Localisation and
Mapping with a Single Camera. In Proceedings of the In-
ternational Conference on Computer Vision (ICCV), 2003.
2, 4, 16
[9] A. J. Davison. Active Search for Real-Time Vision. In Pro-
ceedings of the International Conference on Computer Vi-
sion (ICCV), 2005. 15
[10] A. J. Davison, N. D. Molton, I. Reid, and O. Stasse.
MonoSLAM: Real-Time Single Camera SLAM.
IEEE
Transactions on Pattern Analysis and Machine Intelligence
(PAMI), 29(6):1052–1067, 2007. 16
[11] F. Dellaert and M. Kaess. Square Root SAM: Simultane-
ous Localization and Mapping via Square Root Informa-
tion Smoothing. International Journal of Robotics Research
(IJRR), 25:1181–1203, 2006. 13
[12] J. Engel, T. Schoeps, and D. Cremers. LSD-SLAM: Large-
scale direct monocular SLAM. In Proceedings of the Euro-
pean Conference on Computer Vision (ECCV), 2014. 8, 16
[13] C. Finn, X. Y. Tan, Y. Duan, T. Darrell, S. Levine, and
P. Abbeel. Deep spatial autoencoders for visuomotor learn-
ing. In arXiv preprint:1509.06113, 2015. 2
[14] C. Forster, M. Pizzoli, and D. Scaramuzza. SVO: Fast Semi-
Direct Monocular Visual Odometry. In Proceedings of the
IEEE International Conference on Robotics and Automation
(ICRA), 2014. 16
[15] S. B. Furber, F. Galluppi, S. Temple, and L. A. Plana. The
SpiNNaker Project. Proceedings of the IEEE, 102:652–665,
2014. 5
[16] S. Gupta, J. Davidson, S. Levine, R. Sukthankar, and J. Ma-
lik. Cognitive mapping and planning for visual navigation.
arXiv preprint arXiv:1702.03920, 2017. 3
[17] A. Handa, M. Bloesch, V. Patraucean, S. Stent, J. McCor-
mac, and A. J. Davison. gvnn: Neural network library for ge-
ometric computer vision. arXiv preprint arXiv:1607.07405,
2016. 3
[18] A. Handa, R. A. Newcombe, A. Angeli, and A. J. Davi-
son.
Real-Time Camera Tracking: When is High Frame-
Rate Best? In Proceedings of the European Conference on
Computer Vision (ECCV), 2012. 6
[19] A. Handa, T. Whelan, J. B. McDonald, and A. J. Davison.
A Benchmark for RGB-D Visual Odometry, 3D Reconstruc-
tion and SLAM. In Proceedings of the IEEE International
Conference on Robotics and Automation (ICRA), 2014. 16
[20] M.
Jaderberg,
K.
Simonyan,
A.
Zisserman,
and
K. Kavukcuoglu.
Spatial transformer networks.
arXiv
preprint arXiv:1506.02025, 2015. 3
[21] S. James, A. J. Davison, and E. Johns. Transferring End-
to-End Visuomotor Control from Simulation to Real World
for a Multi-Stage Task . In Conference on Robot Learning
(CoRL), 2017. 2
[22] M. Kaess, H. Johannsson, R. Roberts, V. Ila, J. Leonard, and
F. Dellaert. iSAM2: Incremental Smoothing and Mapping
Using the Bayes Tree. International Journal of Robotics Re-
search (IJRR), 2012. To appear. 8
[23] H. Kim, S. Leutenegger, and A. J. Davison. Real-time 3D
reconstruction, 6-DoF tracking and intensity reconstruction
with an event camera. In Proceedings of the European Con-
ference on Computer Vision (ECCV), 2016. 6
[24] G. Klein and D. W. Murray.
Parallel Tracking and Map-
ping for Small AR Workspaces. In Proceedings of the Inter-
national Symposium on Mixed and Augmented Reality (IS-
MAR), 2007. 15, 16
[25] K. Konolige. Sparse Sparse Bundle Adjustment. In Pro-
ceedings of the British Machine Vision Conference (BMVC),
2010. 13
[26] K. Konolige and M. Agrawal. FrameSLAM: From Bundle
Adjustment to Real-Time Visual Mapping. IEEE Transac-
tions on Robotics (T-RO), 24:1066–1077, 2008. 8
[27] A. Krizhevsky, I. Sutskever, and G. Hinton. ImageNet classi-
ﬁcation with deep convolutional neural networks. In Neural
Information Processing Systems (NIPS), 2012. 5
[28] S. Leutenegger, S. Lynen, M. Bosse, R. Siegwart, and P. Fur-
gale. Keyframe-based visual-inertial odometry using non-
linear optimization. The International Journal of Robotics
Research, 34(3):314–334, 2014. 4, 16
[29] S. J. Lovegrove. Parametric Dense Visual SLAM. PhD thesis,
Imperial College London, 2011. 14
[30] B. D. Lucas and T. Kanade. An Iterative Image Registra-
tion Technique with an Application to Stereo Vision. In Pro-
ceedings of the International Joint Conference on Artiﬁcial
Intelligence (IJCAI), 1981. 14
[31] J. Markoff. Machines of Loving Grace: The Quest for Com-
mon Ground Between Humans and Robots. HarperCollins,
2016. 1
[32] J. Martel and P. Dudek. Vision chips with in-pixel processors
for high-performance low-power embedded vision systems.
In ASR-MOV Workshop, CGO, 2016. 6, 14
[33] J. McCormac, A. Handa, A. J. Davison, and S. Leutenegger.
SemanticFusion: Dense 3D semantic mapping with convo-
lutional neural networks.
In Proceedings of the IEEE In-
ternational Conference on Robotics and Automation (ICRA),
2017. 2, 3, 4, 9
[34] J. McCormac, A. Handa, S. Leutenegger, and A. J. Davison.
SceneNet RGB-D: Can 5M synthetic images beat generic
ImageNet pre-training on indoor segmentation?
In Pro-
ceedings of the International Conference on Computer Vi-
sion (ICCV), 2017. 16
[35] C. Mei, G. Sibley, M. Cummins, P. Newman, and I. Reid.
RSLAM: A System for Large-Scale Mapping in Constant-
Time Using Stereo. International Journal of Computer Vi-
sion (IJCV), 94:198–214, 2011. 8
[36] R. Mur-Artal, J. M. M. Montiel, and J. D. Tard´os. ORB-
SLAM: a Versatile and Accurate Monocular SLAM System.
IEEE Transactions on Robotics (T-RO), 31(5):1147–1163,
2015. 16
[37] L. Nardi, B. Bodin, S. Saeedi, E. Vespa, A. J. Davison, and
P. H. J. Kelly. Algorithmic performance-accuracy trade-off
in 3d vision applications using hypermapper. arXiv preprint
arXiv:1702.00505, 2017. 17
[38] L. Nardi, B. Bodin, M. Z. Zia, J. Mawer, A. Nisbet, P. H.
Kelly, A. J. Davison, M. Lujan, M. F. OBoyle, G. Riley,
N. Topham, and S. Furber.
Introducing SLAMBench, a
performance and accuracy benchmarking methodology for
SLAM. In Proceedings of the IEEE International Confer-
ence on Robotics and Automation (ICRA), 2015. 1, 9, 10,
16
[39] R. A. Newcombe. Dense Visual SLAM. PhD thesis, Imperial
College London, 2012. 9, 14
[40] R. A. Newcombe, D. Fox, and S. M. Seitz. Dynamicfusion:
Reconstruction and tracking of non-rigid scenes in real-time.
In Proceedings of the IEEE Conference on Computer Vision
and Pattern Recognition (CVPR), 2015. 9
[41] R. A. Newcombe, S. Izadi, O. Hilliges, D. Molyneaux,
D. Kim, A. J. Davison, P. Kohli, J. Shotton, S. Hodges,
and A. Fitzgibbon.
KinectFusion: Real-Time Dense Sur-
face Mapping and Tracking.
In Proceedings of the Inter-
national Symposium on Mixed and Augmented Reality (IS-
MAR), 2011. 5, 9, 16
[42] R. A. Newcombe, S. Lovegrove, and A. J. Davison. DTAM:
Dense Tracking and Mapping in Real-Time. In Proceedings
of the International Conference on Computer Vision (ICCV),
2011. 2, 5, 9, 15
[43] J. Pearl. Theoretical impediments to machine learning, with
seven sparks from the causal revolution. Technical report,
University of California, Los Angeles, 2017. Technical Re-
port R-275. 2
[44] T. Pock.
Fast Total Variation for Computer Vision.
PhD
thesis, Graz University of Technology, 2008. 8, 14
[45] T. Pock, M. Grabner, and H. Bischof. Real-time Computa-
tion of Variational Methods on Graphics Hardware. In Pro-
ceedings of the Computer Vision Winter Workshop, 2007. 4
[46] E. Rosten and T. Drummond. Machine learning for high-
speed corner detection. In Proceedings of the European Con-
ference on Computer Vision (ECCV), 2006. 15
[47] M. R¨unz and L. Agapito. Co-Fusion: Real-time segmenta-
tion, tracking and fusion of multiple objects. In Proceedings
of the IEEE International Conference on Robotics and Au-
tomation (ICRA), 2017. 9
[48] S. Saeedi, L. Nardi, E. Johns, B. Bodin, P. Kelly, and
A. Davison. Application-oriented design space exploration
for SLAM algorithms. In Proceedings of the IEEE Inter-
national Conference on Robotics and Automation (ICRA),
2017. 16
[49] R. F. Salas-Moreno, R. A. Newcombe, H. Strasdat, P. H. J.
Kelly, and A. J. Davison. SLAM++: Simultaneous Local-
isation and Mapping at the Level of Objects. In Proceed-
ings of the IEEE Conference on Computer Vision and Pattern
Recognition (CVPR), 2013. 4, 8, 9, 15
[50] T. Schmidt, R. Newcombe, and D. Fox. Self-supervised vi-
sual descriptor learning for dense correspondence. In Pro-
ceedings of the IEEE International Conference on Robotics
and Automation (ICRA), 2017. 10
[51] I. Stoica, D. Song, R. A. Popa, D. A. Patterson, M. W. Ma-
honey, R. H. Katz, A. D. Joseph, M. Jordan, J. M. Heller-
stein, J. Gonzalez, K. Goldberg, A. Ghodsi, D. E. Culler, and
P. Abbeel. A Berkeley view of systems challenges for AI.
Technical report, Electrical Engineering and Computer Sci-
ences University of California at Berkeley, 2017. Technical
Report UCB/EECS-2017-159. 2
[52] J. Sturm, N. Engelhard, F. Endres, W. Burgard, and D. Cre-
mers. A Benchmark for the Evaluation of RGB-D SLAM
Systems. In Proceedings of the IEEE/RSJ Conference on In-
telligent Robots and Systems (IROS), 2012. 16
[53] H.
Sutter.
Welcome
to
the
jungle.
URL
https://herbsutter.com/welcome-to-the-jungle, 2011. 4
[54] K. Tateno, F. Tombari, I. Laina, and N. Navab. CNN-SLAM:
Real-time dense monocular slam with learned depth predic-
tion. In Proceedings of the IEEE Conference on Computer
Vision and Pattern Recognition (CVPR), 2017. 2
[55] H. Wen, S. Wang, R. Clark, and N. Trigoni. DeepVO: To-
wards end to end visual odometry with deep recurrent con-
volutional neural networks. In Proceedings of the IEEE In-
ternational Conference on Robotics and Automation (ICRA),
2017. 3
[56] T. Whelan, S. Leutenegger, R. F. Salas-Moreno, B. Glocker,
and A. J. Davison. ElasticFusion: Dense SLAM without a
pose graph. In Proceedings of Robotics: Science and Sys-
tems (RSS), 2015. 9, 16
[57] K. M. Wurm, A. Hornung, M. Bennewitz, C. Stachniss, and
W. Burgard. OctoMap: A Probabilistic, Flexible, and Com-
pact 3D Map Representation for Robotic Systems. In Pro-
ceedings of the ICRA 2010 Workshop on Best Practice in 3D
Perception and Modeling for Mobile Manipulation, 2010. 9
[58] Y. Xiang and D. Fox. DA-RNN: Semantic mapping with
data associated recurrent neural networks.
arXiv preprint
arXiv:1703.03098, 2017. 4
[59] T. Zhou, M. Brown, N. Snavely, and D. G. Lowe. Unsuper-
vised learning of depth and ego-motion from video. In Pro-
ceedings of the IEEE Conference on Computer Vision and
Pattern Recognition (CVPR), 2017. 3, 4
[60] J. Zienkiewicz, A. Tsiotsios, A. J. Davison, and S. Leuteneg-
ger.
Monocular, Real-Time Surface Reconstruction using
Dynamic Level of Detail. In Proceedings of the International
Conference on 3D Vision (3DV), 2016. 9
